\chapter{Implementation}

\section{Design goals}
\label{goals}

Considering potential use cases is an important step when creating the interface and architecture of a library. The purpose of the developed library is to solve a defined decision making problem and in order to do that following input is needed:

\begin{itemize}
	\item Definition of the Markov decision process
	\item Configuration and parameters for solving
\end{itemize}

For the definition of the MDP there are two main use cases. It has either been formally described in a file or it lives within an application. For the first use case it has been decided that the library shall provide functionality to parse a MDP from a file and that additional parsers for other formats can be easily added. For the other use case the library shall expose the model class in the interface so that an external application can create and setup a MDP and then pass it to the library for solving. For this use case a wrapper class would have been an alternative to directly exposing the model class. This alternative has drawbacks due to the different representations possible and also the sizes of the data structures that need to defined. For example providing a wrapper method to set the probability value of a single state transition for a given action would require infeasible many calls for a MDP with a large state and action space. 

A structure containing all necessary parameters shall be exposed in the interface so that the application can setup the structure to its needs and then pass it for solving. 

After solving the typical use case is to analyze the resulting strategy and/or deploy it to the environment it has been created for. This requirement shall be fulfilled by transferring the ownership to an object containing the policy. Owning this object shall enable the application to draw actions for a given state. This requirement is especially crucial for stochastic policies, where the policy object also depends on random number generators. Providing the application with the ownership of a policy enables easy deployment of the optimized strategy. An alternative would have been the transfer of a data structure defining the resulting stochastic or deterministic policy. In case of a stochastic policy this can be a heavily complex data structure (for example when using neural networks as a policy) and has consequently not been considered. 

Since many different solving methods exist, new functionality shall be easy to integrate.

\section{Interface}

Considering the requirements from \autoref{goals} the header \emph{interface.hpp} is provided to the application:

\begin{lstlisting}
struct Params{
	std::string mdp_filepath_;
	std::string module_parser_;
	std::string module_eval_;
	std::string module_policy_;
	std::string module_solver_;
	std::size_t solver_iteration_cnt_;
};
/*
Solve mdp that is defined in a file on the filesystem
*/
std::unique_ptr<Policy> solve_filebased_mdp(const Params& params);
/*
Solve mdp that has been defined by the application
*/
std::unique_ptr<Policy> solve_external_mdp(Model& model,const Params& params);

\end{lstlisting}


\section{Model}

The model class is the core element of library because it holds information about the MDP to be solved. It is initialized using the default constructor and a Parser-Module (\autoref{chaptermodule}) is parsing the MDP definition from the input file to the model class. Since memory for the model class members has to be allocated dynamically, the parsing model class object offers a public method to allocate the required memory for the object. Once the Parser-Module has determined the size of the state and action space, \emph{SetArrays()} can be called to initialize the array data structures of the state transition matrix and the reward matrix. A method to validate the model data is offered by the model class and is called by the Parser-Module to abort parsing if an inconsistency has been detected. 

//MODEL UML

\section{Modules}
\label{chaptermodule}

In order to achieve a high level of extensibility this a base class acts a blue print for classes to read or write the model. Using this common interface enables easy integration which is described in detail in \autoref{integration}. The module class consists of a protected constructor to set its only member: a reference to the model. 

The abstract \emph{Parser} class acts as an interface for concrete Parser implementations. There exist several file formats to describe MDPs. For the sake of a running example, a rudimentary implementation to parse \emph{POMDP} file format \autocite{Cassandra} is provided. 

The abstract \emph{Policy} class as a interface and base class for different variations of \emph{policy improvement}. The \emph{policy mapping } member is an Array3D object in order to both support deterministic policies and stochastic policies. A method is provided to select an action given a certain state. This is needed by Evaluation-implementations. The policy class is also used as a return type for the external interface of the library. This way an external application can use the reference to directly integrate the optimal strategy for the environment. 
The simplest form of policy improvement where always the most promising action is selected has been implemented. 

The abstract \emph{Evaluation} class is also both interface and base class for different ways to evaluate a policy. A simple form of policy evaluation is provided in the library: \emph{iterative policy evaluation}. This method applies \autoref{valuefunction} to update the value of each state. 

The \emph{Solver} interface and base class provides a general solve method. Solving algorithms combine policy evaluation and policy improvement to find the optimal policy. \emph{policy iteration/monte carlo planning} is implemented as an example.

\section{Module factory}
\label{integration}

In order to minimize the amount of effort to integrate for example an additional Parser or Solver, a factory is implemented. This enables integration without adding any references in existing code. To ensure scalability for 

For each new module two classes are necessary.


%Returning a std::unique_ptr is lightweight (no overhead compared to returning a raw pointer) and conveys the correct semantics of a factory function. Whoever called the function obtains exclusive ownership over the fabricated object. If needed, the client can construct a std::shared_ptr out of a std::unique_ptr at the cost of a dynamic memory allocation.
%
%On the other hand, if the client is going to need a std::shared_ptr anyway, it would be more efficient to have the factory use std::make_shared to avoid the additional dynamic memory allocation. Also, there are situations where you simply must use a std::shared_ptr for example, if the destructor of the managed object is non-virtual and the smart pointer is to be converted to a smart pointer to a base class. But a std::shared_ptr has more overhead than a std::unique_ptr so if the latter is sufficient, we would rather avoid that if possible.

\begin{itemize}
	\item Class with new functionality, inheriting from Module Class
	\item Constructor class, inheriting from Constructor template
\end{itemize}


asd
\begin{lstlisting}
template <typename T>
concept ModularType  = std::is_base_of<Module,T>::value;
\end{lstlisting}

\subsection{Constructor}
Each new module 


\subsection{Factory}


\section{Array3D}

To process the state transition matrix and reward structure of a MDP, a multidimensional array implementation is needed. One option is to use \emph{std::vector} holding another std::vector for the two-dimensional case. The std::vector class manages its own resources following RAII (Resource Acquisition Is Initialization)making this a simple and robust solution but performance-wise there is a drawback. The memory for this nested structure will be fragmented which will slow down access. 
In order to make use of std::vector without causing fragmented memory the \emph{Array3d} template class acts as a wrapper to a one-dimensional std::vector. The () operator accepts three indices and maps those to the 1d std:.vector member. The wrapper performs a boundary check on the 3d indices. If successful, the access to the 1d vector can be performed without the need for a boundary check. This further enhances the performance.  

\section{Build}

A makefile is used for compiling the library and linking it to the example (binary: example) as well as the unit tests (binary: tests). The compiler is set to \emph{-std=c++20} since \emph{Concepts} are a \emph{C++20} feature. 

Due to the modular concept, the concrete implementations are not referenced anywhere in the rest of the codebase. Since registration of all modules is done via instantiating unreferenced, static variables, the linker has to be told to not drop any unreferenced symbols. This is achieved using the \emph{-whole-archive} flag. The linker on macOS requires a different flag. This is considered by setting an OS variable when executing make: \emph{make OS=osx}.



\section{Testing}

\emph{Catch2}\autocite{Catch} has been chosen as a test framework. It is a header only library which eases integration. Test cases for each class are located in the same directory with a \emph{\_t.cc} suffix. The build process generates an executable containing all tests in the \emph{bin} directory. Overall 48 assertions in 8 different test cases are evaluated. 
Testing the \emph{concepts and constraints} is split up from the overall testing since the expected outcome is a compile-timer error. Manual compilation and review of following file is required to validate the introduced concept: concepts\_t.cxx.
